;;;;;;;;;;;;;;;;;;
;; D.1 - type 1
;;;;;;;;;;;;;;;;;;
blobDataStart:
        ; B == blobLen
        0 => HASHPOS,E
        E                               :MSTORE(indexPosBlobData)
        ; check blobDataLen === BYTES_ETH_BLOB_DATA
        $ => B                          :MLOAD(blobDataLen)
        B - %BYTES_ETH_BLOB_DATA        :JMPNZ(failAssert)

; check first byte == 0x00 from 32 bytes & copy to polEvalFrBLS12381_pol_eval[i]
addBlobDataMem:
        %INDEX_Z_HASH_P => E
        $ => A                          :HASHP32(E)
        $ => E                          :MLOAD(indexPosBlobData)
        E + 1                           :MSTORE(indexPosBlobData)
        ;copy from data to polEvalFrBLS12381_pol_eval
        A                               :MSTORE(polEvalFrBLS12381_pol_eval+E)
        B - 32 => B
        31 => D                         :CALL(SHRarith)
        ; A == first byte, check A == 0x00
        A                               :JMPNZ(invalidBlobData)
        B                               :JMPZ(addBlobDataMem2,addBlobDataMem)

; if byte0 != 0x00 --> invalidBlobData and update polEvalFrBLS12381_index & add to polEvalFrBLS12381_pol_eval
invalidBlobData:
        E                               :MSTORE(polEvalFrBLS12381_index)

addBlobDataMemInvalid:
        %INDEX_Z_HASH_P => E
        $ => A                          :HASHP(E)
        $ => E                          :MLOAD(indexPosBlobData)
        E + 1                           :MSTORE(indexPosBlobData)  
        A                               :MSTORE(polEvalFrBLS12381_pol_eval+E)
        B - 32 => B                     :JMPNZ(addBlobDataMemInvalid)
                                        :CALL(polEvalFrBLS12381)
                                        :JMP(invalidBlob)

; copy polEvalFrBLS12381_pol_eval to blobData_without_0 (delete 0x00 byte)
addBlobDataMem2:
        ; call polEvalFrBLS12381
                                        :CALL(polEvalFrBLS12381)
        $ => A                          :MLOAD(polEvalFrBLS12381_y)
        ; assert output pointY
        $ => B                          :MLOAD(y)
        B                               :ASSERT

        0 => E,C,B
        0                               :MSTORE(indexPosBlobData)
        0                               :MSTORE(indexPosBlobDataWithout0)

initLoopBlobDataMem2:
        $ => E                          :MLOAD(indexPosBlobData)
        E + 1                           :MSTORE(indexPosBlobData)
        ; get polEvalFrBLS12381_pol_eval with index E
        $ => A                          :MLOAD(polEvalFrBLS12381_pol_eval+E)
        ; C counter 0 to 31, to calculate mem_align
        C + 1 => C
        1 => D                          :CALL(SHLarith)
        ; A === a without first byte 0x00
        $ => E                          :MLOAD(indexPosBlobDataWithout0)
        ; mstore to blobData_without_0
        A                               :MSTORE(blobData_without_0+E)

loopAddBlobDataMem2:
        $ => E                          :MLOAD(indexPosBlobData)
        $ => A                          :MLOAD(polEvalFrBLS12381_pol_eval+E)
        1 => D                          :CALL(SHLarith)
        32 - C => D                     :CALL(SHRarith)
        C + 1 => C
        $ => E                          :MLOAD(indexPosBlobDataWithout0)
        $ => B                          :MLOAD(blobData_without_0+E)
        A + B => A
        A                               :MSTORE(blobData_without_0+E)
        E + 1                           :MSTORE(indexPosBlobDataWithout0)
        $ => E                          :MLOAD(indexPosBlobData)
        E + 1                           :MSTORE(indexPosBlobData)
        $ => A                          :MLOAD(polEvalFrBLS12381_pol_eval+E)
        C => D                          :CALL(SHLarith)
        $ => E                          :MLOAD(indexPosBlobDataWithout0)
        A                               :MSTORE(blobData_without_0+E)
        C                               :MSTORE(arithA)
        31                              :MSTORE(arithB),CALL(divARITH)
        $ => A                          :MLOAD(arithRes2),JMPZ(lastLoopBlobDataMem2,loopAddBlobDataMem2)

lastLoopBlobDataMem2:
        $ => E                          :MLOAD(indexPosBlobData)
        $ => A                          :MLOAD(polEvalFrBLS12381_pol_eval+E)
        $ => E                          :MLOAD(indexPosBlobDataWithout0)
        $ => B                          :MLOAD(blobData_without_0+E)
        A + B => A
        A                               :MSTORE(blobData_without_0+E)
        E - 3967                        :JMPZ(finalizeBlobData)
        0 => C
        E + 1 => E                      :MSTORE(indexPosBlobDataWithout0),JMP(initLoopBlobDataMem2)

; compute batchHashData from blobData_without_0
finalizeBlobData:
        0 => D,E,C,HASHPOS
        0                               :MSTORE(indexPosBlobDataWithout0)
        C + 1 => C
        ; first byte compression type
        $ => A                          :MLOAD(blobData_without_0+E)
        28 => D
        $ => A                          :MEM_ALIGN_RD,CALL(SHRarith)
        A                               :MSTORE(totalBodyLen)
        ; 4 bytes blobLen        
        C + 4 => C                      :MSTORE(checkBlobDataPos)

initReadBatch:
        ; update ctx + 1
        $ => B                          :MLOAD(numBatches)
        B + 1 => CTX
        $ => A                          :MLOAD(totalBodyLen)
        $ => B                          :MLOAD(checkBlobDataPos)
        ; check blobDataPos == totalBodyLen + 1 byte type compression + 4 bytes blobLen --> final
        B - A - 5                       :JMPZ(finalizeBlob)
        B                               :MSTORE(arithA)
        32                              :MSTORE(arithB),CALL(divARITH)
        ; calculate E index from blobData_without_0 & C offset to mem_align
        $ => E                          :MLOAD(arithRes1)
        $ => C                          :MLOAD(arithRes2)
        $ => A                          :MLOAD(blobData_without_0+E)
        E + 1 => E                      :MSTORE(indexPosBlobDataWithout0)
        $ => B                          :MLOAD(blobData_without_0+E)
        28 => D
        $ => A                          :MEM_ALIGN_RD,CALL(SHRarith)
        $ => C                          :MLOAD(checkBlobDataPos)
        ; 4 bytes batchLen
        C + 4 => C                      :MSTORE(checkBlobDataPos)
        A => B                          :JMPZ(initReadBatch),MSTORE(batchLen)
        B                               :MSTORE(batchHashToRead)

readBatch:
        $ => B                          :MLOAD(batchHashToRead)
        B - 32                          :JMPN(finalReadBatch),MSTORE(batchHashToRead)
        C                               :MSTORE(arithA)
        32                              :MSTORE(arithB),CALL(divARITH)
        $ => E                          :MLOAD(arithRes1)
        $ => C                          :MLOAD(arithRes2)
        $ => A                          :MLOAD(blobData_without_0+E)
        E + 1 => E
        $ => B                          :MLOAD(blobData_without_0+E)
        ; read 32 bytes
        $ => A                          :MEM_ALIGN_RD
        $ => C                          :MLOAD(checkBlobDataPos)
        C + 32 => C                     :MSTORE(checkBlobDataPos)
        $ => E                          :MLOAD(lastHashPIdUsed)
        ; add 32 bytes to hashP
        A                               :HASHP32(E),JMP(readBatch)

finalReadBatch:
        ; B num last bytes
        B => D                          :JMPZ(nextBatch)
        C                               :MSTORE(arithA)
        32                              :MSTORE(arithB),CALL(divARITH)
        $ => E                          :MLOAD(arithRes1)
        $ => C                          :MLOAD(arithRes2)
        $ => A                          :MLOAD(blobData_without_0+E)
        E + 1 => E                      :MSTORE(indexPosBlobDataWithout0)
        $ => B                          :MLOAD(blobData_without_0+E)
        $ => E                          :MLOAD(lastHashPIdUsed)
        32 - D => D
        $ => A                          :MEM_ALIGN_RD,CALL(SHRarith)
        32 - D => D
        $ => C                          :MLOAD(batchLen)
        $ => B                          :MLOAD(checkBlobDataPos)
        B + D                           :MSTORE(checkBlobDataPos)
        A                               :HASHP(E),JMP(nextBatch)