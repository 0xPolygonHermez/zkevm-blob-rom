;;;;;;;;;;;;;;;;;;
;; D.1 - type 1
;;;;;;;;;;;;;;;;;;
blobDataStart:
        ; B == blobLen
        0 => HASHPOS,RR,B
        ; check blobDataLen === BYTES_ETH_BLOB_DATA
        $ => A                          :MLOAD(blobDataLen)
        A - %BYTES_ETH_BLOB_DATA        :JMPNZ(failAssert)

; check first byte == 0x00 from 32 bytes & copy to polEvalFrBLS12381_pol_eval[i]
addBlobDataMem:
        %INDEX_Z_HASH_P => E
        ; A == first byte, check A == 0x00
        $ => A                          :HASHP1(E),JMPNZ(invalidBlobData)
        ;copy from data to polEvalFrBLS12381_pol_eval
        $                               :HASHP31(E),MSTORE(polEvalFrBLS12381_pol_eval+RR)
        RR + 1 => RR
        RR - %NUM_ARRAY_ETH_BLOB_DATA   :JMPZ(callAndAssert,addBlobDataMem)

; if byte0 != 0x00 --> invalidBlobData and update polEvalFrBLS12381_index & add to polEvalFrBLS12381_pol_eval
invalidBlobData:
        RR                              :MSTORE(polEvalFrBLS12381_index)
        ; offset = 1 byte + len = 1 byte + left_alignment
        ; store in 31th byte, 0th byte of A
        1 + 128 * 1 + 8192  => C
        $ => A                          :MEM_ALIGN_RD
        ; read pending 31 bytes and adding whit
        $ + A => A                      :F_HASHP31(E)
        A                               :MSTORE(polEvalFrBLS12381_pol_eval+RR)
        RR + 1 => RR
        RR - %NUM_ARRAY_ETH_BLOB_DATA   :JMPZ(addBlobDataMemInvalid)

addBlobDataMemInvalid:
        $                               :HASHP32(E),MSTORE(polEvalFrBLS12381_pol_eval+RR)
        RR + 1 => RR                    
        RR - %NUM_ARRAY_ETH_BLOB_DATA   :JMPNZ(addBlobDataMemInvalid)

finalBlobDataMemInvalid:
                                        :CALL(polEvalFrBLS12381)
                                        :JMP(invalidBlob)

callAndAssert:
        ; call polEvalFrBLS12381
                                        :CALL(polEvalFrBLS12381)
        $ => A                          :MLOAD(polEvalFrBLS12381_y)
        ; assert output pointY
        $ => B                          :MLOAD(y)
        B                               :ASSERT

        0 => B,RR
        31 - 1 - 4 => RCX
        ; reading type
        $ => A                          :MLOAD(polEvalFrBLS12381_pol_eval[RR])
        1 + 128 * 1 => C
        $ => C                          :MEM_ALIGN_RD

        ; getting totalBatchData
        2 + 128 * 4 => C
        $                               :MEM_ALIGN_RD,MSTORE(totalBodyLen)

        ; A = current 31 bits value
        ; RR = current index array 31 bits value
        ; RCX = remaining bytes on A
        ; D = batch data len

readBatchDataLen:
        ; update ctx + 1
        $ => B                          :MLOAD(numBatches)
        B + 1 => CTX
        $ => C                          :MLOAD(totalBodyLen)
        $ => B                          :MLOAD(blobDataProcessed)
        ; check blobDataProcessed == totalBodyLen + 1 byte type compression + 4 bytes blobLen --> final
        B - C                           :JMPZ(finalizeBlob)
        0 => HASHPOS, B
        32 - RCX + 128 * 4  => C        :JMP_EQ(32+128*4,readBytesBatchDataLenOnTop)

        ; read 4 bytes, if there are not enought bytes it's filled with zero of m1(B)
        $ => D                          :MEM_ALIGN_RD
        RCX - 4 => RCX                  :JMP_LE(0, readRemainingBatchDataLen,readBatchData)
                
; all batchlen it's at begining of memory
readBytesBatchDataLenOnTop:
        RR + 1 => RR
        $ => A                          :MLOAD(polEvalFrBLS12381_pol_eval[RR])
        ; offset = 1, len = 4 bytes
        1 + 128 * 4 => C
        $ => D                          :MEM_ALIGN_RD
        31 - 4 => RCX                   :JMP(readBatchData)
    
; read rest of bytes of batchDataLen
readRemainingBatchDataLen:
        RR + 1 => RR
        RCX + 31 => RCX                 :JMP_EQ(31, readBatchData)
        $ => A                          :MLOAD(polEvalFrBLS12381_pol_eval[RR])
        1 - 128 * RCX + 31 * 128  => C   
        $ => C                          :MEM_ALIGN_RD
        D + C => D

; check if A has pending bytes, this bytes belongs to current BatchData
; three posibilities:
;   batchDataLen (D) === 0
;   pending bytes (RCX) <= batchDataLen (D)  ==> hash this RCX bytes
;   pending bytes (RCX) > batchDataLen (D) ==> hash only D bytes

readBatchData:
        $ => E                          :MLOAD(lastHashPIdUsed)
        D                               :JMP_EQ(0,hashBatchDataEnd), MSTORE(batchLen)
        4095 * 31 - RR * 31 + RCX - D   :JMPN(invalidBlob)
        
        RCX                             :JMP_EQ(0, loopHash31BytesOfBatchData)
        D - RCX                         :JMPN(allBatchDataInRemainingBytes)

allRemainingBytesBelongsBatchData:
        RCX => D
        32 - RCX + 128 * D => C
        $ => C                          :MEM_ALIGN_RD
        C                               :HASHP(E)
        batchLen - RCX => D             :JMP_GE(31, loopHash31BytesOfBatchData, hashLastBytesOfBatchData)
        
allBatchDataInRemainingBytes:
        32 - SP + 128 * D => C
        $                               :MEM_ALIGN_RD,HASHP(E)
        SP - D => SP                    :JMP(hashBatchDataEnd)

; hash speed up 31 bytes
loopHash31BytesOfBatchData:
        RR + 1 => RR
        ${mem.polEvalFrBLS12381_pol_eval[RR]}     :HASHP31(E),MLOAD(polEvalFrBLS12381_pol_eval[RR])
        D - 31 => D                               :JMP_GE(31, loopHash31BytesOfBatchData)

; hash the last bytes of batch
hashLastBytesOfBatchData:
        1 + 128 * D  => C               :JMP_EQ(1, hashBatchDataEnd)
        RR + 1 => RR
        $ => A                          :MLOAD(polEvalFrBLS12381_pol_eval[RR])
        $ => C                          :MEM_ALIGN_RD
        C                               :HASHP(E)

hashBatchDataEnd:
        $ => B                          :MLOAD(blobDataProcessed)
        $ => C                          :MLOAD(batchLen)
        ; C batchLen + 4 bytes of batch length
        C + B + 4                       :MSTORE(blobDataProcessed),JMP(nextBatch)
