;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; POST: The result is in the range [0,BLS12_381_R) because if falls back to Fr arithmetic
;;
;; expBy4096BLS12381:
;;             in: A ∈ [0, 2²⁵⁶-1]
;;             out: A = A⁴⁰⁹⁶ (mod BLS12_381_R) ∈ Fr
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

VAR GLOBAL expBy4096BLS12381_RR

expBy4096BLS12381:
        RR              :MSTORE(expBy4096BLS12381_RR)

        ; Is A = 0?
        0n => B
        $       :EQ, JMPC(expBy4096BLS12381_input_is_zero)

        ; Is A = 1?
        1n => B
        $       :EQ, JMPC(expBy4096BLS12381_input_is_one)

        12 => RCX

                        :JMP(expBy4096BLS12381_loop)

; Begin of branching
expBy4096BLS12381_input_is_zero:
        ; 0⁴⁰⁹⁶ = 0
        0n => A         :JMP(expBy4096BLS12381_end)

expBy4096BLS12381_input_is_one:
        ; 1⁴⁰⁹⁶ = 1
        1n => A         :JMP(expBy4096BLS12381_end)
; End of branching

expBy4096BLS12381_loop:
        RCX - 1 => RCX         :JMPZ(expBy4096BLS12381_end)

        :CALL(squareFrBLS12381)
        :JMP(expBy4096BLS12381_loop)

expBy4096BLS12381_end:
        $ => RR         :MLOAD(expBy4096BLS12381_RR)
                        :RETURN

