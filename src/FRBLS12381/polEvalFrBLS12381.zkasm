;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;  PRE: z is in the range [0,BLS12_381_R) and all evals are set in polEvalFrBLS12381_pol_eval (including the case it is sparse)
;; POST: The result is in the range [0,BLS12_381_R)
;;
;; polEvalFrBLS12381:
;;          input: A polynomial f(X) = ∑ᵢ f(ωⁱ)·Lᵢ(X) in Fr[X], represented in the Lagrange basis,
;;                 with i ∈ [4096] and an evaluation point z ∈ Fr
;;          output: The evaluation:
;;                          f(z) = (z⁴⁰⁹⁶-1)/4096·∑ᵢ fᵢ·ωⁱ/(z-ωⁱ) ∈ Fr
;;
;; NOTE: Lᵢ are the Lagrange polynomials on the multiplicative subgroup of Fr of order 4096
;;       and ω is the 4096-th primitive root of unity in Fr
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

INCLUDE "./rootsOfUnity4096FrBLS12381.zkasm"

VAR GLOBAL polEvalFrBLS12381_pol_eval[4096]
VAR GLOBAL polEvalFrBLS12381_z

VAR GLOBAL polEvalFrBLS12381_accum
VAR GLOBAL polEvalFrBLS12381_inv_i

VAR GLOBAL polEvalFrBLS12381_result

VAR GLOBAL polEvalFrBLS12381_RR

; NOTE: If z is a 4096-th root of unity, say ωⁱ, we should return the i-th evaluation of the polynomial

polEvalFrBLS12381:
        RR              :MSTORE(polEvalFrBLS12381_RR)

        ; Objective: f(z) = (z⁴⁰⁹⁶-1)/4096·∑ᵢ fᵢ·ωⁱ/(z-ωⁱ)

        ; 1] Compute (z⁴⁰⁹⁶-1)/4096
        $ => A          :MLOAD(polEvalFrBLS12381_z), CALL(expBy4096FrBLS12381)

        ; Check whether z is a 4096-th root of unity.
        $0{check4096Root(mem.polEvalFrBLS12381_z)}      :JMPZ(polEvalFrBLS12381_z_is_not_root_of_unity)
        1n                                              :ASSERT

        ; The following method returns the index of the associated root
        $0{get4096RootIndex(mem.polEvalFrBLS12381_z)} => E

        ; Check that the received index and the root are correctly related
                        :CALL(@rootsOfUnity4096FrBLS12381 + E) ; [out: C]
        $ => A          :MLOAD(polEvalFrBLS12381_z)
        C               :ASSERT

        ; Return the corresponding evaluation
        $ => A          :MLOAD(polEvalFrBLS12381_pol_eval + E)
        A               :MSTORE(polEvalFrBLS12381_result), JMP(polEvalFrBLS12381_end)

polEvalFrBLS12381_z_is_not_root_of_unity:
        ; Objective: f(z) = (z⁴⁰⁹⁶-1)/4096·∑ᵢ fᵢ·ωⁱ/(z-ωⁱ)

        ; ensure its not a 4096-th root of unity
        1n => B
        0               :EQ

        1n => C         :CALL(subFrBLS12381)
        C => A
        %BLS12_381_R_4096_inv => B      :CALL(mulFrBLS12381)
        C                               :MSTORE(polEvalFrBLS12381_result)

        ; 2] Compute ∑ᵢ fᵢ·ωⁱ/(z-ωⁱ)
        0               :MSTORE(polEvalFrBLS12381_accum) ; Initialize the accumulator
        4095 => RCX
polEvalFrBLS12381_loop:
        RCX => E
        ; 2.1] Compute 1/(z-ωⁱ)
        $ => A          :MLOAD(polEvalFrBLS12381_z)
                        :CALL(@rootsOfUnity4096FrBLS12381 + E) ; [out: C]
                        :CALL(subFrBLS12381)
        C => A          :CALL(invFrBLS12381)
        A               :MSTORE(polEvalFrBLS12381_inv_i)

        ; 2.2] Compute fᵢ·ωⁱ and multiply by 1/(z-ωⁱ)
        RCX => E
        $ => A          :MLOAD(polEvalFrBLS12381_pol_eval + E)
                        :CALL(@rootsOfUnity4096FrBLS12381 + E)
        C => B          :CALL(mulFrBLS12381)
        $ => B          :MLOAD(polEvalFrBLS12381_inv_i), CALL(mulFrBLS12381)

        ; 2.3] Accumulate the i-th term
        $ => A          :MLOAD(polEvalFrBLS12381_accum), CALL(addFrBLS12381)
        C               :MSTORE(polEvalFrBLS12381_accum)

        RCX - 1 => RCX  :JMPN(polEvalFrBLS12381_last_mul, polEvalFrBLS12381_loop)

polEvalFrBLS12381_last_mul:
        ; 3] Multiply the accumulator by (z⁴⁰⁹⁶-1)/4096
        $ => A          :MLOAD(polEvalFrBLS12381_accum)
        $ => B          :MLOAD(polEvalFrBLS12381_result), CALL(mulFrBLS12381)
        C               :MSTORE(polEvalFrBLS12381_result)

polEvalFrBLS12381_end:
        $ => RR         :MLOAD(polEvalFrBLS12381_RR)
                        :RETURN