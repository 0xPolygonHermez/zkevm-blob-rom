;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;  PRE: All the 4096 evals must be set in polEvalFrBLS12381_pol_eval[4096]
;; POST: Each pol_eval_i gets reduced to [0,BLS12_381_R) if necessary, for i in [0,4095]
;;       The resulting evaluation y is in the range [0,BLS12_381_R)
;;
;; polEvalFrBLS12381:
;;          input: A polynomial f(X) = ∑ᵢ f(ωⁱ)·Lᵢ(X) in Fr[X], represented in the Lagrange basis,
;;                 with i ∈ [4096] and an evaluation point z ∈ Fr
;;          output: The evaluation:
;;                          f(z) = (z⁴⁰⁹⁶-1)/4096·∑ᵢ fᵢ·ωⁱ/(z-ωⁱ) ∈ Fr
;;
;; NOTE: Lᵢ are the Lagrange polynomials on the multiplicative subgroup of Fr of order 4096
;;       and ω is the 4096-th primitive root of unity in Fr
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

INCLUDE "./rootsOfUnity4096FrBLS12381.zkasm"

VAR GLOBAL polEvalFrBLS12381_pol_eval[4096]
VAR GLOBAL polEvalFrBLS12381_index ; index of first pol_eval with alias from 1 to 4096; 0 if none have alias
VAR GLOBAL polEvalFrBLS12381_z

VAR GLOBAL polEvalFrBLS12381_accum
VAR GLOBAL polEvalFrBLS12381_inv_i

VAR GLOBAL polEvalFrBLS12381_y ; output

VAR GLOBAL polEvalFrBLS12381_RR

; NOTE: If z is a 4096-th root of unity, say ωⁱ, we should return the i-th evaluation of the polynomial

; RESOURCES:
; -------------------------------------------
; PATH 1 z_is_root:
;               · z_is_one:     [steps: 23,  bin: 2]
;               · z_is_not_one: [steps: 94, bin: 2, arith: 12]
; PATH 2 z_is_not_root: inital_exp_and_first_term       + 4096*i-th_term                          + last_mul_and_end             =
;                       [steps: 102, bin: 6, arith: 13] + 4096*[steps: 39-43, bin: 2-4, arith: 4] + [steps: 9, bin: 0, arith: 1] =
;                                      [steps: 159.855-176.239, bin: 8.198-16.390, arith: 16.398]
; PATH 3 z_is_not_root: PATH 2 + reduce_all = [steps: 159.855-176.239, bin: 8.198-16.390, arith: 16.398] + [steps: 20, bin: 1, arith: 2] + [steps: 53.237, bin: 4.095, arith: 4.095] =
;                                      [steps: 213.112-229.496, bin: 12.294-20.486, arith: 20.495] <--- w.c.
; -------------------------------------------

polEvalFrBLS12381:
        RR              :MSTORE(polEvalFrBLS12381_RR)

        ; Reduce z to the range [0,BLS12_381_R) if necessary
        $ => A          :MLOAD(polEvalFrBLS12381_z)
        %BLS12_381_R => B
        $               :LT, JMPC(polEvalFrBLS12381_check_index)
                        :CALL(reduceFrBLS12381) ; [steps: 5, bin: 0, arith: 1]
        ; [steps: 10, bin: 1, arith: 1]
        A               :MSTORE(polEvalFrBLS12381_z)

polEvalFrBLS12381_check_index:
        $ => RCX          :MLOAD(polEvalFrBLS12381_index), JMPZ(polEvalFrBLS12381_compute)
        ; Index is in range [1,4096]

        ; Reduce pol_eval_i to the range [0,BLS12_381_R) if necessary
        RCX - 1 => RCX,E
        $ => A          :MLOAD(polEvalFrBLS12381_pol_eval + E), CALL(reduceFrBLS12381) ; [steps: 5, bin: 0, arith: 1]
        RCX => E
        A               :MSTORE(polEvalFrBLS12381_pol_eval + E)
        ; [steps: 20, bin: 1, arith: 2]

polEvalFrBLS12381_reduce_evals:
        ; w.c. loop -> 4095*[steps: 13, bin: 1, arith: 1] + 2*steps = [steps: 53.237, bin: 4.095, arith: 4.095]

        RCX + 1 => RCX,E
        4096 - RCX      :JMPZ(polEvalFrBLS12381_compute)
        $ => A          :MLOAD(polEvalFrBLS12381_pol_eval + E)
        %BLS12_381_R => B
        $               :LT, JMPC(polEvalFrBLS12381_reduce_evals)
                        :CALL(reduceFrBLS12381) ; [steps: 5, bin: 0, arith: 1]
        RCX => E
        A               :MSTORE(polEvalFrBLS12381_pol_eval + E), JMP(polEvalFrBLS12381_reduce_evals)

polEvalFrBLS12381_compute:
        ; Objective: f(z) = (z⁴⁰⁹⁶-1)/4096·∑ᵢ fᵢ·ωⁱ/(z-ωⁱ)

        ; 1] Compute (z⁴⁰⁹⁶-1)/4096
        $ => A          :MLOAD(polEvalFrBLS12381_z), CALL(expBy4096FrBLS12381) ; [steps: 80, bin: 2, arith: 12] <-- w.c.

        ; Check whether z is a 4096-th root of unity by checking if z⁴⁰⁹⁶ = 1
        $0{check4096Root(mem.polEvalFrBLS12381_z)}      :JMPZ(polEvalFrBLS12381_z_is_not_root_of_unity)
        ; [steps: 83, bin: 2, arith: 12]

polEvalFrBLS12381_z_is_root_of_unity:
        1n                                              :ASSERT

        ; The following method returns the index of the associated root
        $0{get4096RootIndex(mem.polEvalFrBLS12381_z)} => E      :JMPN(failAssert) ; if E < 0 ERROR

        ; Check that the received index is in the range [0,4095]
        4095 - E      :JMPN(failAssert) ; if E > 4095 ERROR

        ; Check that the received index and the root in z are correctly related
                        :CALL(@rootsOfUnity4096FrBLS12381 + E) ; [out: C]
        $ => A          :MLOAD(polEvalFrBLS12381_z)
        C               :ASSERT

        ; Return the corresponding evaluation
        $ => A          :MLOAD(polEvalFrBLS12381_pol_eval + E)
        A               :MSTORE(polEvalFrBLS12381_y), JMP(polEvalFrBLS12381_end)
        ; till the end -> [steps: 94, bin: 2, arith: 12]

polEvalFrBLS12381_z_is_not_root_of_unity:
        ; before -> [steps: 83, bin: 2, arith: 12]

        ; Objective: f(z) = (z⁴⁰⁹⁶-1)/4096·∑ᵢ fᵢ·ωⁱ/(z-ωⁱ)

        ; ensure z its not a 4096-th root of unity
        1n => B
        0               :EQ

        1n => C         :CALL(subFrBLS12381) ; [steps: 7, bin: 3, arith: 0] <-- w.c.
        C => A
        %BLS12_381_R_4096_inv => B      :CALL(mulFrBLS12381) ; [steps: 4, bin: 0, arith: 1]
        C                               :MSTORE(polEvalFrBLS12381_y)

        ; 2] Compute ∑ᵢ fᵢ·ωⁱ/(z-ωⁱ)
        0               :MSTORE(polEvalFrBLS12381_accum) ; Initialize the accumulator
        4095 => RCX
        ; [steps: 102, bin: 6, arith: 13]
polEvalFrBLS12381_loop:
        ; block costs: [steps: 39-43, bin: 2-4, arith: 4]

        RCX => E
        ; 2.1] Compute 1/(z-ωⁱ)
        $ => A          :MLOAD(polEvalFrBLS12381_z)
                        :CALL(@rootsOfUnity4096FrBLS12381 + E) ; [out: C]
                        :CALL(subFrBLS12381) ; [steps: 3, bin: 1]-[steps: 7, bin: 3] <-- w.c.
        C => A          :CALL(invFrBLS12381) ; [steps: 7, bin: 1, arith: 1]
        A               :MSTORE(polEvalFrBLS12381_inv_i)

        ; 2.2] Compute fᵢ·ωⁱ and multiply by 1/(z-ωⁱ)
        RCX => E
        $ => A          :MLOAD(polEvalFrBLS12381_pol_eval + E)
                        :CALL(@rootsOfUnity4096FrBLS12381 + E) ; [out: C]
        C => B          :CALL(mulFrBLS12381) ; [steps: 4, bin: 0, arith: 1]
        C => A
        $ => B          :MLOAD(polEvalFrBLS12381_inv_i), CALL(mulFrBLS12381) ; [steps: 4, bin: 0, arith: 1]

        ; 2.3] Accumulate the i-th term
        $ => A          :MLOAD(polEvalFrBLS12381_accum), CALL(addFrBLS12381) ; [steps: 4, bin: 0, arith: 1]
        C               :MSTORE(polEvalFrBLS12381_accum)

        RCX - 1 => RCX  :JMPN(polEvalFrBLS12381_last_mul, polEvalFrBLS12381_loop)

polEvalFrBLS12381_last_mul:
        ; till the end costs -> [steps: 9, bin: 0, arith: 1]

        ; 3] Multiply the accumulator by (z⁴⁰⁹⁶-1)/4096
        $ => A          :MLOAD(polEvalFrBLS12381_accum)
        $ => B          :MLOAD(polEvalFrBLS12381_y), CALL(mulFrBLS12381) ; [steps: 4, bin: 0, arith: 1]
        C               :MSTORE(polEvalFrBLS12381_y)

polEvalFrBLS12381_end:
        $ => RR         :MLOAD(polEvalFrBLS12381_RR)
                        :RETURN