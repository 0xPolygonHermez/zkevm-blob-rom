;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;  PRE: The input is not zero
;; POST: The result is in the range [0,BLS12_381_R)
;;
;; invFrBLS12381:
;;             in: A ∈ [1, 2²⁵⁶-1]
;;             out: A = A⁻¹ (mod BLS12_381_R) ∈ Fr
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

invFrBLS12381:
        ; A·A⁻¹ + 0 = 1 (mod BLS12_381_R)
        ${var _invFrBLS12381_A = frBLS12_381inv(A)} => B
        0 => C
        %BLS12_381_R => D
        1n                      :ARITH_MOD

        ; Check that the resulting inverse is alias-free
        B => A
        %BLS12_381_R => B
        1                       :LT, RETURN