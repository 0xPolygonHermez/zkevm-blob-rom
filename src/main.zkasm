INCLUDE "constants-blob.zkasm"
INCLUDE "vars-blob.zkasm"
INCLUDE "constantsBLS12381.zkasm"

; Blocks blob-rom
;       A - Load input variables
;       B - Compute 'newBlobAccInputHash'
;       C - Check type input
;               C.0 - Type 0: calldata
;               C.1 - Type 1: ethereum blob transaction
;               C.2 - Type 2: calldata and it is a forced one
;       D - batchHashData - finalAccBatchHashData
;       D.0 - type 0 & 2: Prepare batchHashData & finalAccBatchHashData
;       D.1 - type 1: check 0x00, compute batchHashData & finalAccBatchHashData
;       E - Finalize execution

; type 0 & 1 & 2 : HASHK(0) --> newBlobAccInputHash
; type 0 & 2: HASHK(1) --> blobL2Hashdata = keccak256(blobData)
; type 1: HASHP(0) --> z = poseidon(blobData)
; type 0 & 1 & 2 : HASHP(X) --> batchHashData

start:

;;;;;;;;;;;;;;;;;;
;; A - Load input variables
;;;;;;;;;;;;;;;;;;
        STEP => A
        0                               :ASSERT ; Ensure it is the beginning of the execution

        RCX                             :MSTORE(forkID)
        RCX - %FORK_ID                  :JMPNZ(failAssert)
        B => A                          :MSTORE(oldBlobStateRoot)

        ; safety check that the input root is indeed inside the range limit of 4 goldilocks fields elements
        %FOUR_GOLDILOCKS => B
        1                               :LT4
        
        C                               :MSTORE(oldBlobAccInputHash)
        RR                              :MSTORE(oldNumBlob)
        D                               :MSTORE(oldStateRoot)

        ${getLastL1InfoTreeIndex()}     :MSTORE(lastL1InfoTreeIndex)
        ${getLastL1InfoTreeRoot()}      :MSTORE(lastL1InfoTreeRoot)
        ${getTimestampLimit()}          :MSTORE(timestampLimit)
        ${getSequencerAddr()}           :MSTORE(sequencerAddr)
        ${getZkGasLimit()}              :MSTORE(zkGasLimit)
        ${getType()}                    :MSTORE(type)
        ${getBlobL2HashData()}          :MSTORE(blobL2HashData) ; used when type = 0
        ${getZ()}                       :MSTORE(polEvalFrBLS12381_z) ; used when type = 1
        ${getY()}                       :MSTORE(y) ; used when type = 1
        ${getForcedHashData()}          :MSTORE(forcedHashData) ; used when type = 2

        ${getBlobLen()} => B            :MSTORE(blobDataLen)

        ;$${eventLog(onStartBlob)}

        $ => SR                         :MLOAD(oldBlobStateRoot)

        ; update numBlob
        $ => A                          :MLOAD(oldNumBlob)
        A + 1                           :MSTORE(newNumBlob)

;;;;;;;;;;;;;;;;;;
;; B - Compute newBlobAccInputHash = keccak256(oldBlobAccInputHash, lastL1InfoTreeIndex, lastL1InfoTreeRoot, timestampLimit, sequenceraddress, zkGasLimit, type, z, y, blobL2Hashdata, forcedHashdata)
;;;;;;;;;;;;;;;;;;


        0 => HASHPOS                    :MSTORE(blobHashPos)
        ; compute newBlobAccInputHash to HASHK index 0
        %INDEX_ACC_BLOB_INPUT_HASH_K => E

        32 => D
        $ => A                          :MLOAD(oldBlobAccInputHash)
        A                               :HASHK(E)

        4 => D
        $ => A                          :MLOAD(lastL1InfoTreeIndex)
        A                               :HASHK(E)

        32 => D
        $ => A                          :MLOAD(lastL1InfoTreeRoot)
        A                               :HASHK(E)

        8 => D
        $ => A                          :MLOAD(timestampLimit)
        A                               :HASHK(E)

        20 => D
        $ => A                          :MLOAD(sequencerAddr)
        A                               :HASHK(E)

        32 => D
        $ => A                          :MLOAD(zkGasLimit)
        A                               :HASHK(E)

        1 => D
        $ => A                          :MLOAD(type)
        A                               :HASHK(E)

        32 => D
        $ => A                          :MLOAD(polEvalFrBLS12381_z)
        A                               :HASHK(E)

        $ => A                          :MLOAD(y)
        A                               :HASHK(E)

        $ => A                          :MLOAD(blobL2HashData)
        A                               :HASHK(E)

        $ => A                          :MLOAD(forcedHashData)
        A                               :HASHK(E)

        ; finish newBlobAccInputHash
        HASHPOS                         :HASHKLEN(E)

        $ => C                          :HASHKDIGEST(E)
        C                               :MSTORE(newBlobAccInputHash)

;;;;;;;;;;;;;;;;;;
;; C - Check type input
;;;;;;;;;;;;;;;;;;
        ; B == blobLen
        $ => A                          :MLOAD(type)
        A - 1                           :JMPN(standarCalldata)
        A - 2                           :JMPN(blobData)
        A - 3                           :JMPN(forcedBlob)
                                        :JMP(invalidBlob)

;;;;;;;;;;;;;;;;;;
;; C.0 - Type 0
;;;;;;;;;;;;;;;;;;
standarCalldata:
        ; B == blobDataLen (getBlobLen())
        $ => A                          :MLOAD(blobL2HashData) ; used when type = 0
        ; load blobL2HashData = keccak256(blobData) to HASHK index 1
        %INDEX_BLOB_L2_HASH_K_DATA => E
        A                               :HASHKDIGEST(E)
        B => HASHPOS
        HASHPOS                         :HASHKLEN(E)
        
        ; Check blobData <= MAX_BYTES_ZK_BLOB_DATA (126976 bytes)
        %MAX_BYTES_ZK_BLOB_DATA - B     :JMPN(invalidBlob)
                                        :JMP(type0and2)

;;;;;;;;;;;;;;;;;;
;; C.1 - Type 1
;;;;;;;;;;;;;;;;;;
blobData:
        ; B == blobDataLen (getBlobLen())
        $ => A                          :MLOAD(polEvalFrBLS12381_z)
        ; load z = poseidon(blobData) to HASHP index 0
        %INDEX_Z_HASH_P => E
        A                               :HASHPDIGEST(E)
        B => HASHPOS
        HASHPOS                         :HASHPLEN(E)

        ; Check blobData <= BYTES_ETH_BLOB_DATA (4096 * 32 bytes)
        %BYTES_ETH_BLOB_DATA - B        :JMPN(invalidBlob)

        ; isEIP4844 = 1 & update lastHASHPIDUsed
        1                               :MSTORE(isEIP4844)
        1                               :MSTORE(lastHashPIdUsed)
                                        :JMP(computeBatchHashData)

;;;;;;;;;;;;;;;;;;
;; C.2 - Type 2
;;;;;;;;;;;;;;;;;;
forcedBlob:
        ; B == blobDataLen (getBlobLen())
        $ => A                          :MLOAD(forcedHashData)
        ; Check blobData <= MAX_BYTES_ZK_BLOB_DATA (126976 bytes)
        %MAX_BYTES_ZK_BLOB_DATA - B     :JMPN(invalidBlob)
        ; load forcedHashData to HASHK index 1
        1 => E
        A                               :HASHKDIGEST(E)

type0and2:
        ; sanity check
        0                               :MSTORE(isEIP4844)
        0                               :MSTORE(lastHashPIdUsed)

;;;;;;;;;;;;;;;;;;
;; D - batchHashData - finalAccBatchHashData
;;;;;;;;;;;;;;;;;;
computeBatchHashData:
        0 => HASHPOS ; HASHPOS of blobData

        ; if type = 1 => blobDataStart
        $ => A                          :MLOAD(isEIP4844)
        A                               :JMPNZ(blobDataStart)

        ; if type = 0 || type = 2
        $ => E                          :MLOAD(lastHashPIdUsed)

        ; blobData[0] --> compression type
        1 => D                          :CALL(addBlobInputHashK) ; A = first byte
        A => B
        ; blobData[1]-blobData[4] --> totalBodyLen
        4 => D                          :CALL(addBlobInputHashK) ; A = totalBodyLen
        ; blobDataLen = totalBody + compression type (1 byte) + totalBodyLen (4 bytes)
        A                               :MSTORE(totalBodyLen)
        $ => D                          :MLOAD(blobDataLen)
        D - A - 5                       :JMPNZ(invalidBlob)
        B - 1                           :JMPN(nonCompression)
                                        :JMP(invalidTypeCompression)

;;;;;;;;;;;;;;;;;;
;; D.0 - type 0 & 2: Prepare batchHashData & finalAccBatchHashData
;;;;;;;;;;;;;;;;;;
nonCompression:
        $ => A                          :MLOAD(blobDataLen)
        ; check if HASHPOS == blobDataLen --> finalizeBlob
        A - HASHPOS                     :JMPZ(finalizeBlob)

        $ => B                          :MLOAD(type)
        B - 2                           :JMPNZ(addBatchData)
        ; if type == 2 --> only one batch is supported
        $ => B                          :MLOAD(numBatches)
        1 - B                           :JMPZ(invalidBlob)

addBatchData:
        ; change CTX
        $ => B                          :MLOAD(numBatches)
        B + 1 => CTX
        ; 4 bytes --> batch length
        4 => D                          :CALL(addBlobInputHashK)
        A                               :MSTORE(batchLen)
        0 => C  ; position of batchData
        A - 1                           :JMPN(nonCompression) ; if batchLen == 0 --> no finalAccBatchHashData
        
; loop bytes from blolbData to batchData
addData:
        A                               :JMPZ(nextBatch)
        A - 32                          :JMPN(endData),MSTORE(batchHashToRead)
        ;add blobL2Hashdata
        32 => D                         :CALL(addBlobInputHashK)
        ;add batchHashData
                                        :CALL(addBatchInputHash)
        $ => A                          :MLOAD(batchHashToRead),JMP(addData)

; last bytes
endData:
        A => D                          :CALL(addBlobInputHashK)
                                        :CALL(addBatchInputHash)

nextBatch:
        ; batchHashData = LinearPoseidon(batchData)
        HASHPOS                         :MSTORE(blobHashPos)
        C => HASHPOS                    :HASHPLEN(E)
        $ => B                          :HASHPDIGEST(E)
        ;$${eventLog(onAddBatch(E))}
        B                               :MSTORE(batchHashData)
        E + 1 => E                      :MSTORE(lastHashPIdUsed)

        ; compute finalAccBatchHashData
        ; finalAccBatchHashData = LinearPoseidon(oldBatchAccInputHash, batchHashData, sequencerAddress, forcedData, type))
        0 => HASHPOS

        32 => D
        $ => B                          :MLOAD(finalAccBatchHashData)
        B                               :HASHP(E)
        $ => B                          :MLOAD(batchHashData)
        B                               :HASHP(E)

        20 => D
        $ => B                          :MLOAD(sequencerAddr)
        B                               :HASHP(E)

        32 => D
        ; forçar que sigui 0000 si el type != 2
        $ => B                          :MLOAD(forcedData)
        B                               :HASHP(E)

        ; TODO: borrar aixo
        1 => D
        $ => B                          :MLOAD(type)
        B                               :HASHP(E)

        HASHPOS                         :HASHPLEN(E)
        $ => B                          :HASHPDIGEST(E)
        B                               :MSTORE(finalAccBatchHashData)

        ; update numBatches + 1
        $ => B                          :MLOAD(numBatches)
        B + 1                           :MSTORE(numBatches)
        0 => B
        $ => HASHPOS                    :MLOAD(blobHashPos)

        ; update last Id hashP used
        E + 1 => E                      :MSTORE(lastHashPIdUsed)
        $                               :MLOAD(isEIP4844),JMPZ(nonCompression, initReadBatch)

invalidTypeCompression:
invalidBlob:
        1                               :MSTORE(isInvalid)
        0                               :MSTORE(finalAccBatchHashData)
        SR                              :MSTORE(tmpSR)
        $ => SR                         :MLOAD(oldStateRoot)
        %ADDRESS_GLOBAL_EXIT_ROOT_MANAGER_L2  => A
        %SMT_KEY_SC_STORAGE => B
        %LOCAL_EXIT_ROOT_STORAGE_POS => C
        $ => A                          :SLOAD
        A                               :MSTORE(newLocalExitRootFromBlob)
        $ => SR                         :MLOAD(tmpSR)
                                        :JMP(finalizeBlobInvalid)

;;;;;;;;;;;;;;;;;;
;; D.1 - type 1
;;;;;;;;;;;;;;;;;;
blobDataStart:
        ; B == blobLen
        0 => HASHPOS,E
        E                               :MSTORE(indexPosBlobData)
        ; check blobDataLen === BYTES_ETH_BLOB_DATA
        $ => B                          :MLOAD(blobDataLen)
        B - %BYTES_ETH_BLOB_DATA        :JMPNZ(failAssert)

; check first byte == 0x00 from 32 bytes & copy to polEvalFrBLS12381_pol_eval[i]
addBlobDataMem:
        %INDEX_Z_HASH_P => E
        $ => A                          :HASHP32(E)
        $ => E                          :MLOAD(indexPosBlobData)
        E + 1                           :MSTORE(indexPosBlobData)
        ;copy from data to polEvalFrBLS12381_pol_eval
        A                               :MSTORE(polEvalFrBLS12381_pol_eval+E)
        B - 32 => B
        31 => D                         :CALL(SHRarith)
        ; A == first byte, check A == 0x00
        A                               :JMPNZ(invalidBlobData)
        B                               :JMPZ(addBlobDataMem2,addBlobDataMem)

; if byte0 != 0x00 --> invalidBlobData and update polEvalFrBLS12381_index & add to polEvalFrBLS12381_pol_eval
invalidBlobData:
        E                               :MSTORE(polEvalFrBLS12381_index)
        1                               :MSTORE(isInvalid)
addBlobDataMemInvalid:
        %INDEX_Z_HASH_P => E
        $ => A                          :HASHP(E)
        $ => E                          :MLOAD(indexPosBlobData)
        E + 1                           :MSTORE(indexPosBlobData)  
        A                               :MSTORE(polEvalFrBLS12381_pol_eval+E)
        B - 32 => B                     :JMPZ(finalizeBlob,addBlobDataMemInvalid)

; copy polEvalFrBLS12381_pol_eval to blobData_without_0 (delete 0x00 byte)
addBlobDataMem2:
        ; call polEvalFrBLS12381
                                        :CALL(polEvalFrBLS12381)
        $ => A                          :MLOAD(polEvalFrBLS12381_y)
        ; assert output pointY
        $ => B                          :MLOAD(y)
        B                               :ASSERT

        0 => E,C,B
        0                               :MSTORE(indexPosBlobData)
        0                               :MSTORE(indexPosBlobDataWithout0)

initLoopBlobDataMem2:
        $ => E                          :MLOAD(indexPosBlobData)
        E + 1                           :MSTORE(indexPosBlobData)
        ; get polEvalFrBLS12381_pol_eval with index E
        $ => A                          :MLOAD(polEvalFrBLS12381_pol_eval+E)
        ; C counter 0 to 31, to calculate mem_align
        C + 1 => C
        1 => D                          :CALL(SHLarith)
        ; A === a without first byte 0x00
        $ => E                          :MLOAD(indexPosBlobDataWithout0)
        ; mstore to blobData_without_0
        A                               :MSTORE(blobData_without_0+E)

loopAddBlobDataMem2:
        $ => E                          :MLOAD(indexPosBlobData)
        $ => A                          :MLOAD(polEvalFrBLS12381_pol_eval+E)
        1 => D                          :CALL(SHLarith)
        32 - C => D                     :CALL(SHRarith)
        C + 1 => C
        $ => E                          :MLOAD(indexPosBlobDataWithout0)
        $ => B                          :MLOAD(blobData_without_0+E)
        A + B => A
        A                               :MSTORE(blobData_without_0+E)
        E + 1                           :MSTORE(indexPosBlobDataWithout0)
        $ => E                          :MLOAD(indexPosBlobData)
        E + 1                           :MSTORE(indexPosBlobData)
        $ => A                          :MLOAD(polEvalFrBLS12381_pol_eval+E)
        C => D                          :CALL(SHLarith)
        $ => E                          :MLOAD(indexPosBlobDataWithout0)
        A                               :MSTORE(blobData_without_0+E)
        C                               :MSTORE(arithA)
        31                              :MSTORE(arithB),CALL(divARITH)
        $ => A                          :MLOAD(arithRes2),JMPZ(lastLoopBlobDataMem2,loopAddBlobDataMem2)

lastLoopBlobDataMem2:
        $ => E                          :MLOAD(indexPosBlobData)
        $ => A                          :MLOAD(polEvalFrBLS12381_pol_eval+E)
        $ => E                          :MLOAD(indexPosBlobDataWithout0)
        $ => B                          :MLOAD(blobData_without_0+E)
        A + B => A
        A                               :MSTORE(blobData_without_0+E)
        E - 3967                        :JMPZ(finalizeBlobData)
        0 => C
        E + 1 => E                      :MSTORE(indexPosBlobDataWithout0),JMP(initLoopBlobDataMem2)

; compute batchHashData from blobData_without_0
finalizeBlobData:
        0 => D,E,C,HASHPOS
        0                               :MSTORE(indexPosBlobDataWithout0)
        C + 1 => C
        ; first byte compression type
        $ => A                          :MLOAD(blobData_without_0+E)
        ;E + 1 => E
        ;$ => B                          :MLOAD(blobData_without_0+E)
        ;28 => D
        ;$ => A                          :MEM_ALIGN_RD,CALL(SHRarith)
                                        :CALL(SHRarith)
        A                               :MSTORE(totalBodyLen)
        ; 4 bytes blobLen        
        C + 4 => C                      :MSTORE(checkBlobDataPos)

initReadBatch:
        ; update ctx + 1
        $ => B                          :MLOAD(numBatches)
        B + 1 => CTX
        $ => A                          :MLOAD(totalBodyLen)
        $ => B                          :MLOAD(checkBlobDataPos)
        ; check blobDataPos == totalBodyLen + 1 byte type compression + 4 bytes blobLen --> final
        B - A - 5                       :JMPZ(finalizeBlob)
        B                               :MSTORE(arithA)
        32                              :MSTORE(arithB),CALL(divARITH)
        ; calculate E index from blobData_without_0 & C offset to mem_align
        $ => E                          :MLOAD(arithRes1)
        $ => C                          :MLOAD(arithRes2)
        $ => A                          :MLOAD(blobData_without_0+E)
        E + 1 => E                      :MSTORE(indexPosBlobDataWithout0)
        $ => B                          :MLOAD(blobData_without_0+E)
        28 => D
        $ => A                          :MEM_ALIGN_RD,CALL(SHRarith)
        $ => C                          :MLOAD(checkBlobDataPos)
        ; 4 bytes batchLen
        C + 4 => C                      :MSTORE(checkBlobDataPos)
        A => B                          :JMPZ(initReadBatch),MSTORE(batchLen)
        B                               :MSTORE(batchHashToRead)

readBatch:
        $ => B                          :MLOAD(batchHashToRead)
        B - 32                          :JMPN(finalReadBatch),MSTORE(batchHashToRead)
        C                               :MSTORE(arithA)
        32                              :MSTORE(arithB),CALL(divARITH)
        $ => E                          :MLOAD(arithRes1)
        $ => C                          :MLOAD(arithRes2)
        $ => A                          :MLOAD(blobData_without_0+E)
        E + 1 => E
        $ => B                          :MLOAD(blobData_without_0+E)
        ; read 32 bytes
        $ => A                          :MEM_ALIGN_RD
        $ => C                          :MLOAD(checkBlobDataPos)
        C + 32 => C                     :MSTORE(checkBlobDataPos)
        $ => E                          :MLOAD(lastHashPIdUsed)
        ; add 32 bytes to hashP
        A                               :HASHP32(E),JMP(readBatch)

finalReadBatch:
        ; B num last bytes
        B => D                          :JMPZ(nextBatch)
        C                               :MSTORE(arithA)
        32                              :MSTORE(arithB),CALL(divARITH)
        $ => E                          :MLOAD(arithRes1)
        $ => C                          :MLOAD(arithRes2)
        $ => A                          :MLOAD(blobData_without_0+E)
        E + 1 => E                      :MSTORE(indexPosBlobDataWithout0)
        $ => B                          :MLOAD(blobData_without_0+E)
        $ => E                          :MLOAD(lastHashPIdUsed)
        32 - D => D
        $ => A                          :MEM_ALIGN_RD,CALL(SHRarith)
        32 - D => D
        $ => C                          :MLOAD(batchLen)
        $ => B                          :MLOAD(checkBlobDataPos)
        B + D                           :MSTORE(checkBlobDataPos)
        A                               :HASHP(E),JMP(nextBatch)

finalizeBlob:
;;;;;;;;;;;;;;;;;;
;; E. Finalize execution
;;;;;;;;;;;;;;;;;;
        $ => A                          :MLOAD(zkGasLimit)
        A                               :MSTORE(arithA)
        %ZKGAS_PER_BATCH                :MSTORE(arithB),CALL(divARITH)
        $ => A                          :MLOAD(arithRes1)
        $ => B                          :MLOAD(numBatches)
        $                               :LT,JMPC(invalidBlob)

finalizeBlobInvalid:

        ;$${eventLog(onFinishBlob)}

        ; safety check that the output root is indeed inside the range limit of 4 goldilocks fields elements
        SR => A                         :MSTORE(newBlobStateRoot)
        %FOUR_GOLDILOCKS => B
        1                               :LT4

        ; Set registers to its initials values
        $ => B                          :MLOAD(oldBlobStateRoot)
        $ => C                          :MLOAD(oldBlobAccInputHash)
        $ => RR                         :MLOAD(oldNumBlob)
        $ => D                          :MLOAD(oldStateRoot)
        $ => RCX                        :MLOAD(forkID)

                                        :SAVE(B,C,D,E,RR,RCX)

        ; Set output registers
        $ => B                          :MLOAD(newBlobStateRoot)
        $ => C                          :MLOAD(newBlobAccInputHash)
        $ => GAS                        :MLOAD(newNumBlob)
        $ => A                          :MLOAD(finalAccBatchHashData)
        $ => E                          :MLOAD(localExitRootFromBlob)
        $ => CTX                        :MLOAD(isInvalid)

        $ => RR                         :MLOAD(timestampLimit)
        $ => D                          :MLOAD(lastL1InfoTreeRoot)
        $ => RCX                        :MLOAD(lastL1InfoTreeIndex)

finalizeExecution:
                                        :JMP(finalWait)

INCLUDE "utils-blob.zkasm"
INCLUDE "end-blob.zkasm"
INCLUDE "./FRBLS12381/reduceFrBLS12381.zkasm"
INCLUDE "./FRBLS12381/addFrBLS12381.zkasm"
INCLUDE "./FRBLS12381/subFrBLS12381.zkasm"
INCLUDE "./FRBLS12381/mulFrBLS12381.zkasm"
INCLUDE "./FRBLS12381/squareFrBLS12381.zkasm"
INCLUDE "./FRBLS12381/invFrBLS12381.zkasm"
INCLUDE "./FRBLS12381/expBy4096FrBLS12381.zkasm"
INCLUDE "./FRBLS12381/polEvalFrBLS12381.zkasm"