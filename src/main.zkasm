INCLUDE "constants-blob.zkasm"
INCLUDE "vars-blob.zkasm"

; Blocks zkROM
;       A - Load initial registers into memory: oldStateRoot (B), oldAccInputHash (C), oldNumBatch (SP) & chainID (GAS)

;       F - Finalize execution

; HASHK(0) --> newAccBlobInputHash = keccak256(oldAccBlobInputHash, lastL1InfoTreeIdx, lastL1InfoTreeRoot, timestampLimit, sequenceraddress, zkGasLimit, type, z, y, blobL2Hashdata, forcedHashdata)
; type 0 & 2: HASHK(1) --> blobL2Hashdata = keccak256(blobData)
; type 1: HASHP(0) --> z = poseidon(blobData)

start:

;;;;;;;;;;;;;;;;;;
;; A - Load input variables
;;;;;;;;;;;;;;;;;;
        STEP => A
        0                               :ASSERT ; Ensure it is the beginning of the execution

        RCX                             :MSTORE(forkID)
        RCX - %FORK_ID                  :JMPNZ(failAssert)

        B => A                          :MSTORE(oldBlobStateRoot)

        ; safety check that the input root is indeed inside the range limit of 4 goldilocks fields elements
        %FOUR_GOLDILOCKS => B
        1                               :LT4
        
        C                               :MSTORE(oldBlobAccInputHash)
        RR                              :MSTORE(oldNumBlob)

        ${getTimestampLimit()}          :MSTORE(timestampLimit)
        ${getSequencerAddr()}           :MSTORE(sequencerAddr)
        ${getZkGasLimit()}              :MSTORE(zkGasLimit)
        ${getType()}                    :MSTORE(type)
        ${getZ()}                       :MSTORE(z)
        ${getY()}                       :MSTORE(y)
        
        
        ${getBlobL2HashData()}          :MSTORE(blobL2HashData)
        ${getForcedHashData()}          :MSTORE(forcedHashData)

        ${getBlobLen()}                 :MSTORE(blobDataLen)

;;;;;;;;;;;;;;;;;;
;; B - Check type input
;;;;;;;;;;;;;;;;;;
        $ => A                          :MLOAD(type)
        A - 1                           :JMPN(standarCalldata)
        A - 2                           :JMPN(blobData)
        A - 3                           :JMPN(forcedBlob)
                                        :JMP(invalidBlob)
blobData:
        1                               :MSTORE(isEIP4844)
        1                               :MSTORE(lastHashPIdUsed)
                                        :JMP(computeBlobAccInputHash)

;;;;;;;;;;;;;;;;;;
;; B.1 - Type 0 & 2
;;;;;;;;;;;;;;;;;;
standarCalldata:
forcedBlob:
        0                               :MSTORE(isEIP4844)
        0                               :MSTORE(lastHashPIdUsed)

computeBlobAccInputHash:
;;;;;;;;;;;;;;;;;;
;; C - Compute 'newAccBlobInputHash'
;;;;;;;;;;;;;;;;;;

        0 => HASHPOS

        32 => D
        $ => A                          :MLOAD(oldBlobAccInputHash)
        A                               :HASHK(0)

        4 => D
        $ => A                          :MLOAD(lastL1InfoTreeIdx)
        A                               :HASHK(0)

        32 => D
        $ => A                          :MLOAD(lastL1InfoTreeRoot)
        A                               :HASHK(0)

        8 => D
        $ => A                          :MLOAD(timestampLimit)
        A                               :HASHK(0)

        20 => D
        $ => A                          :MLOAD(sequencerAddr)
        A                               :HASHK(0)

        32 => D
        $ => A                          :MLOAD(zkGasLimit)
        A                               :HASHK(0)

        1 => D
        $ => A                          :MLOAD(type)
        A                               :HASHK(0)

        32 => D
        $ => A                          :MLOAD(z)
        A                               :HASHK(0)

        $ => A                          :MLOAD(y)
        A                               :HASHK(0)

        $ => A                          :MLOAD(blobL2HashData)
        A                               :HASHK(0)

        $ => A                          :MLOAD(forcedHashData)
        A                               :HASHK(0)

        ; finish blobAccInputHash
        HASHPOS                         :HASHKLEN(0)

        $ => C                          :HASHKDIGEST(0)
        C                               :MSTORE(newAccBlobInputHash)

        ; Pointer to next RLP bytes to read
        0 => C
        $ => E                          :MLOAD(lastHashPIdUsed)
    
        $${var p = 0}
        1 => D
        ${getBlobBytes(p,D)} => A
        $${p = p + D}
        C + D => C                      :CALL(addBlobInputHash)
        A - 1                           :JMPN(nonCompression)
                                        :JMP(invalidTypeCompression)

nonCompression:
        $ => A                          :MLOAD(blobDataLen)
        A - C                           :JMPZ(endBlob)
        A - C                           :JMPN(invalidBlob)

        4 => D
        ${getBlobBytes(p,D)} => A       :MSTORE(batchLen)
        $${p = p + D}
        C + D => C                      :CALL(addBlobInputHash)

        A - 1                           :JMPN(nextBatch)

addData:
        A - 32                          :JMPN(endData)
        32 => D                         :CALL(addBatchAccInputHash)
                                        :CALL(addBlobInputHash)
        A - 32 => A                     :JMP(addData)

endData:
        A                               :JMPZ(nextBatch)
        A => D                          :CALL(addBatchAccInputHash)
                                        :CALL(addBlobInputHash)

nextBatch:
        ; batchHashData = LinearPoseidon(batchData)
        ; newBatchAccInputHash = LinearPoseidon(oldBatchAccInputHash, batchHashData, sequencerAddress, forcedData, type))

        HASHPOS                         :HASHPLEN(E)
        $ => B                          :HASHPDIGEST(E)
        B                               :MSTORE(batchHashData)
        E + 1 => E                      :MSTORE(lastHashPIdUsed)

        0 => HASHPOS

        32 => D
        $ => B                          :MLOAD(newBatchAccInputHash)
        B                               :HASHP(E)
        $ => B                          :MLOAD(batchHashData)
        B                               :HASHP(E)

        20 => D
        $ => B                          :MLOAD(sequencerAddr)
        B                               :HASHP(E)

        32 => D
        $ => B                          :MLOAD(forcedData)
        B                               :HASHP(E)

        1 => D
        $ => B                          :MLOAD(type)
        B                               :HASHP(E)

        HASHPOS                         :HASHPLEN(E)
        $ => B                          :HASHPDIGEST(E)
        B                               :MSTORE(newBatchAccInputHash)

        $ => B                          :MLOAD(numBatches)
        B + 1                           :MSTORE(numBatches)
        0 => B
        E + 1 => E                      :MSTORE(lastHashPIdUsed),JMP(nonCompression)


invalidTypeCompression:
invalidBlob:
        1                               :MSTORE(isInvalid)
        0                               :MSTORE(newBatchAccInputHash)
        ;from the oldStateRootFromBlob:
        ;read the newLocalExitRoot and set it to the newLocalExitRootFromBlob
                                        :JMP(finalizeExecution)

endBlob:
        $                               :MLOAD(isEIP4844),JMPNZ(endBlobData)
        $ => HASHPOS                    :MLOAD(blobHashPos)
        HASHPOS                         :HASHKLEN(1)
        $ => A                          :HASHKDIGEST(1)
        A                               :MSTORE(blobL2Hashdata)
                                        :JMP(finalizeBlob)

endBlobData:
        $ => HASHPOS                    :MLOAD(blobHashPos)
        HASHPOS                         :HASHPLEN(0)
        $ => A                          :HASHPDIGEST(0)
        A                               :MSTORE(z)
                                        :CALL(checkBlobInputHash)


finalizeBlob:
;;;;;;;;;;;;;;;;;;
;; Finalize execution
;;;;;;;;;;;;;;;;;;

        $                               :MLOAD(zkGasLimit),MSTORE(arithA)
        %ZKGAS_PER_BATCH                :MSTORE(arithB),CALL(divARITH)
        $ => A                          :MLOAD(arithRes1)
        B                               :MLOAD(numBatches)
        $                               :LT,JMPC(invalidBlob)

        ; safety check that the output root is indeed inside the range limit of 4 goldilocks fields elements
        SR => A
        %FOUR_GOLDILOCKS => B
        1                               :LT4

        ; Set registers to its initials values
        $ => CTX                        :MLOAD(forkID)
        $ => B                          :MLOAD(oldBlobStateRoot)
        $ => C                          :MLOAD(oldBlobAccInputHash)
        $ => RR                         :MLOAD(oldNumBlob)

        A                               :SAVE(B,C,D,E,RR,RCX)

        ; Set output registers
        $ => SR                         :MLOAD(newBlobStateRoot)
        $ => A                          :MLOAD(newBlobAccInputHash)
        $ => CTX                        :MLOAD(newNumBlob)
        $ => B                          :MLOAD(finalAccBatchHashData)
        $ => SP                         :MLOAD(lastTimestampLimit)
        $ => C                          :MLOAD(lastL1InfoTreeRoot)
        $ => RR                         :MLOAD(lastL1InfoTreeIdx)
        $ => D                          :MLOAD(oldStateRootFromBlob)
        $ => E                          :MLOAD(localExitRootFromBlob)
        $ => HASHPOS                    :MLOAD(oldNumBatchFromBlob)
        $ => GAS                        :MLOAD(isValid)

        finalizeExecution:
                                        :JMP(finalWait)

INCLUDE "utils-blob.zkasm"
INCLUDE "end-blob.zkasm"