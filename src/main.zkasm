INCLUDE "constants-blob.zkasm"
INCLUDE "vars-blob.zkasm"

; Blocks zkROM
;       A - Load initial registers into memory

;       F - Finalize execution

; HASHK(0) --> newAccBlobInputHash = keccak256(oldAccBlobInputHash, lastL1InfoTreeIdx, lastL1InfoTreeRoot, timestampLimit, sequenceraddress, zkGasLimit, type, z, y, blobL2Hashdata, forcedHashdata)
; type 0 & 2: HASHK(1) --> blobL2Hashdata = keccak256(blobData)
; type 1: HASHP(0) --> z = poseidon(blobData)
; type 0 & 1 & 2 : batchHashData = HASHP(X)

start:

;;;;;;;;;;;;;;;;;;
;; A - Load input variables
;;;;;;;;;;;;;;;;;;
        STEP => A
        0                               :ASSERT ; Ensure it is the beginning of the execution

        RCX                             :MSTORE(forkID)
        RCX - %FORK_ID                  :JMPNZ(failAssert)

        B => A                          :MSTORE(oldBlobStateRoot)

        ; safety check that the input root is indeed inside the range limit of 4 goldilocks fields elements
        %FOUR_GOLDILOCKS => B
        1                               :LT4
        
        C                               :MSTORE(oldBlobAccInputHash)
        RR                              :MSTORE(oldNumBlob)

        ${getTimestampLimit()}          :MSTORE(timestampLimit)
        ${getSequencerAddr()}           :MSTORE(sequencerAddr)
        ${getZkGasLimit()}              :MSTORE(zkGasLimit)
        ${getType()}                    :MSTORE(type)

        ${getZ()}                       :MSTORE(z) ; used when type = 1
        ${getY()}                       :MSTORE(y) ; used when type = 1
        ${getBlobL2HashData()}          :MSTORE(blobL2HashData) ; used when type = 0
        ${getForcedHashData()}          :MSTORE(forcedHashData) ; used when type = 2

        ${getBlobLen()} => B            :MSTORE(blobDataLen)

;;;;;;;;;;;;;;;;;;
;; B - Check type input
;;;;;;;;;;;;;;;;;;
        $ => A                          :MLOAD(type)
        A - 1                           :JMPN(standarCalldata)
        A - 2                           :JMPN(blobData)
        A - 3                           :JMPN(forcedBlob)
                                        :JMP(invalidBlob)

;;;;;;;;;;;;;;;;;;
;; B.2 - Type 1
;;;;;;;;;;;;;;;;;;
blobData:
        ; Check blobData <= BYTES_ETH_BLOB_DATA (4096 * 32 bytes)
        %BYTES_ETH_BLOB_DATA - B        :JMPN(invalidBlob)
        ; load z = poseidon(blobData) to HASHP index 0
        $ => A                          :MLOAD(z)
        A                               :HASHPDIGEST(0)
        ; isEIP4844 = 1 & update lastHASHPIDUsed
        1                               :MSTORE(isEIP4844)
        1                               :MSTORE(lastHashPIdUsed)
                                        :JMP(computeBlobAccInputHash)

;;;;;;;;;;;;;;;;;;
;; B.1 - Type 0 & 2
;;;;;;;;;;;;;;;;;;
standarCalldata:
        ; Check blobData <= MAX_BYTES_ZK_BLOB_DATA (126976 bytes)
        %MAX_BYTES_ZK_BLOB_DATA - B     :JMPN(invalidBlob)
        ; load blobL2HashData = keccak256(blobData) to HASHK index 1
        $ => A                          :MLOAD(blobL2HashData)
        A                               :HASHKDIGEST(1)

                                        :JMP(type0and2)

forcedBlob:
        ; Check blobData <= MAX_BYTES_ZK_BLOB_DATA (126976 bytes)
        %MAX_BYTES_ZK_BLOB_DATA - B     :JMPN(invalidBlob)
        ; load forcedHashData to HASHK index 1
        $ => A                          :MLOAD(forcedHashData)
        A                               :HASHKDIGEST(1)

type0and2:
        0                               :MSTORE(isEIP4844)
        0                               :MSTORE(lastHashPIdUsed)

computeBlobAccInputHash:
;;;;;;;;;;;;;;;;;;
;; C - Compute 'newAccBlobInputHash'
;;;;;;;;;;;;;;;;;;

        ; compute newAccBlobInputHash to HASHK index 0

        0 => HASHPOS

        32 => D
        $ => A                          :MLOAD(oldBlobAccInputHash)
        A                               :HASHK(0)

        4 => D
        $ => A                          :MLOAD(lastL1InfoTreeIdx)
        A                               :HASHK(0)

        32 => D
        $ => A                          :MLOAD(lastL1InfoTreeRoot)
        A                               :HASHK(0)

        8 => D
        $ => A                          :MLOAD(timestampLimit)
        A                               :HASHK(0)

        20 => D
        $ => A                          :MLOAD(sequencerAddr)
        A                               :HASHK(0)

        32 => D
        $ => A                          :MLOAD(zkGasLimit)
        A                               :HASHK(0)

        1 => D
        $ => A                          :MLOAD(type)
        A                               :HASHK(0)

        32 => D
        $ => A                          :MLOAD(z)
        A                               :HASHK(0)

        $ => A                          :MLOAD(y)
        A                               :HASHK(0)

        $ => A                          :MLOAD(blobL2HashData)
        A                               :HASHK(0)

        $ => A                          :MLOAD(forcedHashData)
        A                               :HASHK(0)

        ; finish blobAccInputHash
        HASHPOS                         :HASHKLEN(0)

        $ => C                          :HASHKDIGEST(0)
        C                               :MSTORE(newAccBlobInputHash)

        ; if type = 1 => blobDataStart
        $ => A                          :MLOAD(isEIP4844)
        A                               :JMPNZ(blobDataStart)

        ; if type = 0 || type = 2
        0 => C
        $ => E                          :MLOAD(lastHashPIdUsed)

        ; first byte --> compression type
        1 => D
        C + D => C                      :CALL(addBlobInputHash) ; A = first byte
        A - 1                           :JMPN(nonCompression)
                                        :JMP(invalidTypeCompression)

nonCompression:
        $ => A                          :MLOAD(blobDataLen)
        A - C                           :JMPZ(endBlob)
        A - C                           :JMPN(invalidBlob)
        
        $ => B                          :MLOAD(type)
        B - 1                           :JMPNZ(addBatchData)
        $ => B                          :MLOAD(numBatches)
        1 - B                           :JMPZ(invalidBlob)

addBatchData;
        ; 4 bytes --> batch length
        4 => D
        C + D => C                      :CALL(addBlobInputHash)
        A                               :MSTORE(batchLen)

        A - 1                           :JMPN(nextBatch)

; loop bytes from blolbData to batchData
addData:
        A - 32                          :JMPN(endData)
        32 => D                         :CALL(addBlobInputHash)
                                        :CALL(addBatchInputHash)
        A - 32 => A                     :JMP(addData)

endData:
        A                               :JMPZ(nextBatch)
        A => D                          :CALL(addBlobInputHash)
                                        :CALL(addBatchInputHash)

nextBatch:
        ; batchHashData = LinearPoseidon(batchData)
        ; newBatchAccInputHash = LinearPoseidon(oldBatchAccInputHash, batchHashData, sequencerAddress, forcedData, type))

        HASHPOS                         :HASHPLEN(E)
        $ => B                          :HASHPDIGEST(E)
        B                               :MSTORE(batchHashData)
        E + 1 => E                      :MSTORE(lastHashPIdUsed)

        ; compute newBatchAccInputHash
        0 => HASHPOS

        32 => D
        $ => B                          :MLOAD(newBatchAccInputHash)
        B                               :HASHP(E)
        $ => B                          :MLOAD(batchHashData)
        B                               :HASHP(E)

        20 => D
        $ => B                          :MLOAD(sequencerAddr)
        B                               :HASHP(E)

        32 => D
        $ => B                          :MLOAD(forcedData)
        B                               :HASHP(E)

        1 => D
        $ => B                          :MLOAD(type)
        B                               :HASHP(E)

        HASHPOS                         :HASHPLEN(E)
        $ => B                          :HASHPDIGEST(E)
        B                               :MSTORE(newBatchAccInputHash)

        $ => B                          :MLOAD(numBatches)
        B + 1                           :MSTORE(numBatches)
        0 => B
        E + 1 => E                      :MSTORE(lastHashPIdUsed)
        $                               :MLOAD(isEIP4844),JMPZ(nonCompression, nextBatchBlobData)

invalidTypeCompression:
invalidBlob:
        1                               :MSTORE(isInvalid)
        0                               :MSTORE(newBatchAccInputHash)
        ;from the oldStateRootFromBlob:
        ;read the newLocalExitRoot and set it to the newLocalExitRootFromBlob
                                        :JMP(finalizeExecution)

endBlob:
        $ => HASHPOS                    :MLOAD(blobHashPos)
        HASHPOS                         :HASHKLEN(1)
        $ => A                          :HASHKDIGEST(1)
        A                               :MSTORE(blobL2Hashdata)
                                        :JMP(finalizeBlob)

blobDataStart:
        0 => C, E
        0 => HASHPOS
        $ => B                          :MLOAD(blobDataLen)
        32 => D
        
addBlobDataMem:
        B - C - D                       :JMPN(endBlobDataLen)
        $ => A                          :HASHP(0)
        A                               :MSTORE(polEvalFrBLS12381_pol_eval+E)
        E + 1 => E
        C + D => C                      :JMP(addBlobDataMem)

endBlobDataLen;
        B - C                           :JMPZ(batchBlobData)
        B - C => D
        $ => A                          :HASHP(0)
        D - 32 => D                     :CALL(SHLarith)
        A                               :MSTORE(polEvalFrBLS12381_pol_eval+E)
        E + 1 => E
        32 => D
        C + D => C

add0sBlobData:
        %BYTES_ETH_BLOB_DATA - C        :JMPZ(batchBlobData)
        0                               :MSTORE(polEvalFrBLS12381_pol_eval+E)
        E + 1 => E
        C + D => C                      :JMP(add0sBlobData)

batchBlobData:

        0 => RR,C

        $ => A                          :MLOAD(polEvalFrBLS12381_pol_eval+RR)
        31 => D                         :CALL(SHRarith)
        ; A == first byte --> 0x00
        A                               :JMPNZ(invalidBlob)
        $ => A                          :MLOAD(polEvalFrBLS12381_pol_eval+RR)
        30 => D                         :CALL(SHRarith)
        ; A ==  0x00 & compression type --> 0x00 | 00
        A                               :JMPNZ(invalidBlob)
        $ => A                          :MLOAD(polEvalFrBLS12381_pol_eval+RR)
        26 => D                         :CALL(SHRarith)
        ; A == 0x00 | 00 | batchlen
        A                               :MSTORE(batchLen)
        $ => A                          :MLOAD(polEvalFrBLS12381_pol_eval+RR)
        6 => D                          :CALL(SHLarith)
        26 => D                         :CALL(addBatchInputHash)
        32 => C
        $ => A                          :MLOAD(batchLen)
        A - 26 => A
        RR + 1 => RR

loopBatchBlobData:
        A - 32                          :JMPN(finalBatchBlobData)
        $ => A                          :MLOAD(polEvalFrBLS12381_pol_eval+RR)
        RR + 1 => RR
        0xFF00000000000000000000000000000000000000000000000000000000000000 => B
        $ => B                          :AND,JMPNZ(invalidBlob)
        1 => D                          :CALL(SHLarith)
        31 => D                         :CALL(addBatchInputHash)
        C + 32 => C
        A - 32 => A                     :JMPZ(nextBatch)

finalBatchBlobData:
        $ => A                          :MLOAD(polEvalFrBLS12381_pol_eval+RR)
        0xFF00000000000000000000000000000000000000000000000000000000000000 => B
        $ => B                          :AND,JMPNZ(invalidBlob)
        A => D                          :CALL(addBatchInputHash)
        C + D => C
                                        :JMP(nextBatch)

nextBatchBlobData:
        $ => A                          :MLOAD(blobDataLen)
        A - C                           :JMPZ(endBlob)
        A - C                           :JMPN(invalidBlob)
        ; if C % 32 == 0 --> get batchLength and loop
        ; if C % 32 != 0 --> get batchLength and loop with SHR/SHL
        C                               :MSTORE(arithA)
        32                              :MSTORE(arithB),CALL(divARITH)
        $ => D                          :MLOAD(arithRes2),JMPZ(nextBatchBlobData32)

nextBatchBlobData32:


finalizeBlob:
;;;;;;;;;;;;;;;;;;
;; Finalize execution
;;;;;;;;;;;;;;;;;;

        $                               :MLOAD(zkGasLimit),MSTORE(arithA)
        %ZKGAS_PER_BATCH                :MSTORE(arithB),CALL(divARITH)
        $ => A                          :MLOAD(arithRes1)
        B                               :MLOAD(numBatches)
        $                               :LT,JMPC(invalidBlob)

        ; safety check that the output root is indeed inside the range limit of 4 goldilocks fields elements
        SR => A
        %FOUR_GOLDILOCKS => B
        1                               :LT4

        ; Set registers to its initials values
        $ => CTX                        :MLOAD(forkID)
        $ => B                          :MLOAD(oldBlobStateRoot)
        $ => C                          :MLOAD(oldBlobAccInputHash)
        $ => RR                         :MLOAD(oldNumBlob)

        A                               :SAVE(B,C,D,E,RR,RCX)

        ; Set output registers
        $ => SR                         :MLOAD(newBlobStateRoot)
        $ => A                          :MLOAD(newBlobAccInputHash)
        $ => CTX                        :MLOAD(newNumBlob)
        $ => B                          :MLOAD(finalAccBatchHashData)
        $ => SP                         :MLOAD(lastTimestampLimit)
        $ => C                          :MLOAD(lastL1InfoTreeRoot)
        $ => RR                         :MLOAD(lastL1InfoTreeIdx)
        $ => D                          :MLOAD(oldStateRootFromBlob)
        $ => E                          :MLOAD(localExitRootFromBlob)
        $ => HASHPOS                    :MLOAD(oldNumBatchFromBlob)
        $ => GAS                        :MLOAD(isInvalid)

        finalizeExecution:
                                        :JMP(finalWait)

INCLUDE "utils-blob.zkasm"
INCLUDE "end-blob.zkasm"