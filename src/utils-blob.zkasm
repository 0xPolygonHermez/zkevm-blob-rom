;@info function to force a failed assert
failAssert:
    1 => A
    2               :ASSERT

addBlobInputHash:
        $ => HASHPOS                    :MLOAD(blobHashPos)
        $ => A                          :HASHK(1)
        HASHPOS                         :MSTORE(blobHashPos)
        C => HASHPOS                    :RETURN

addBatchInputHash:
        $ => B                          :MLOAD(blobDataLen)
        B - C - D                       :JMPN(invalidBlob)
        $ => B                          :MLOAD(batchLen)
        B - HASHPOS - D                 :JMPN(invalidBlob)
        A                               :HASHP(E)
        C + D => C                      :RETURN

;addBlobInputHash:
;        $ => HASHPOS                    :MLOAD(blobHashPos)
;        A                               :HASHK(1)
;        HASHPOS                         :MSTORE(blobHashPos)
;        C => HASHPOS                    :RETURN
;
;addBlobInputHashP:
;        $ => HASHPOS                    :MLOAD(blobHashPos)
;        A                               :HASHP(0)
;        HASHPOS                         :MSTORE(blobHashPos)
;        C => HASHPOS                    :RETURN

;addBatchAccInputHash:
;        ; TODO CHECK BLOB LEN
;        $ => A                          :MLOAD(batchLen)
;        A - HASHPOS - D                 :JMPN(invalidBlob)
;        ${getBlobBytes(p,D)} => A
;        $${p = p + D}
;        A                               :HASHP(E)
;        C + D => C                      :RETURN



;checkBlobInputHash:
;        0 => HASHPOS
;        32 => D
;loopCheckBlobInputHash:
;        $ => B                          :HASHPLEN(0)
;        B - HASHPOS                     :JMPZ(finishCheckBlobHash)
;        B - HASHPOS                     :JMPN(finishCheckBlobHash)
;        $ => A                          :HASHP(0)
;        0x00000000000000000000000000000000000000000000000000000000000000FFn => B
;        $ => A                          :AND
;        A                               :JMPZ(loopCheckBlobInputHash,invalidBlob)
;finishCheckBlobHash:
;                                        :RETURN



;blobDataStart:
;
;        0 => C
;        $ => E                          :MLOAD(lastHashPIdUsed)
;    
;        32 => D
;        $ => A                          :HASHP(0)
;        A                               :MSTORE(polEvalFrBLS12381_pol_eval)
;        26 => D
;                                        :CALL(SHRarith)    
;        ; A = first 6 bytes
;        ; check first 1 byte == 0x00
;        0xFF0000000000 => B
;        $                               :AND,JMPNZ(invalidBlob)
;        C + D => C
;        ; second byte == compression type
;        0xFFFF00000000 => B
;        $ => A                          :AND
;        ; A = compression type
;        A - 1                           :JMPN(nonCompressionBlobData)
;                                        :JMP(invalidTypeCompression)
;
;nonCompressionBlobData:
;        $ => A                          :MLOAD(blobDataLen)
;        A - C                           :JMPZ(endBlobData)
;        A - C                           :JMPN(invalidBlob)
;
;        ; 2-6 bytes --> batchLen
;        
;        C + D => C                      :CALL(addBlobInputHashP)
;
;        A - 1                           :JMPN(nextBatch)
;
;addData:
;        A - 32                          :JMPN(endData)
;        32 => D                         :CALL(addBatchAccInputHash)
;                                        :CALL(addBlobInputHashP)
;        A - 32 => A                     :JMP(addData)
;
;endData:
;        A                               :JMPZ(nextBatch)
;        A => D                          :CALL(addBatchAccInputHash)
;                                        :CALL(addBlobInputHashP)
;                                        :JMPZ(nextBatch)
;
;endBlobData:
;        $ => HASHPOS                    :MLOAD(blobHashPos)
;        %BYTES_ETH_BLOB_DATA - C => B   :JMPZ(endAdd0sData)
;        32 => D
;
;add0sData:
;        B - 32                          :JMPN(finishAdd0sData)
;        0                               :HASHP(0)
;        B - D => B                      :JMP(add0sData)
;
;finishAdd0sData:
;        B => D
;        0                               :HASHP(0)
;
;endAdd0sData:
;        HASHPOS                         :HASHPLEN(0)
;        $ => A                          :HASHPDIGEST(0)
;        A                               :MSTORE(z)
;