;@info function to force a failed assert
failAssert:
    1 => A
    2               :ASSERT

; @info Get D bytes from HASHK with index E (with HASHPOS)
; @in D, E, HASHPOS
; @out A
addBlobInputHashK:
        $ => B                          :MLOAD(blobDataLen)
        B - HASHPOS - D                 :JMPN(invalidBlob)
        E => B
        %INDEX_BLOB_L2_HASH_K_DATA => E
        $ => A                          :HASHK(E)
        B => E                          :RETURN

; @info Add A bytes with D len to HASHP with index E and HASHPOS in C
; @in A, D, E, C
; @out C new HASHPOS
addBatchInputHash:
        HASHPOS                         :MSTORE(blobHashPos)
        $ => B                          :MLOAD(batchLen)
        C => HASHPOS
        A                               :HASHP(E)
        $ => HASHPOS                    :MLOAD(blobHashPos)
        C + D => C                      :RETURN

; @info Shift right D bytes to A
; @in A
; @in D
; @out A - A >> (8*D) => A

SHRarith:
    31 - D      :JMPN(SHRarith_32)
    D           :JMPZ(SHRarith_0)
    32 - D => C :SAVE(B,C,D,E,RCX,RR)
    A => B
    0 => A
    $ => A      :MEM_ALIGN_RD
                :RESTORE, RETURN

SHRarith_32:
    0 => A      :RETURN
SHRarith_0:
                :RETURN

; @info Shift left D bytes to A
; @in A
; @in D
; @out A - A << (8*D) => A


SHLarith:
    31 - D      :JMPN(SHLarith_32)
    D => C      :SAVE(B,C,D,E,RCX,RR),JMPZ(SHLarith_0)
    0 => B
    $ => A      :MEM_ALIGN_RD
                :RESTORE, RETURN

SHLarith_32:
    0 => A      :RETURN
SHLarith_0:
                :RESTORE, RETURN


VAR GLOBAL tmpVarAArith
VAR GLOBAL tmpVarBArith
VAR GLOBAL tmpVarCArith
VAR GLOBAL tmpVarDArith
VAR GLOBAL tmpVarEArith
VAR GLOBAL tmpZkPCArith
VAR GLOBAL arithA
VAR GLOBAL arithB
VAR GLOBAL arithRes1
VAR GLOBAL arithRes2
; @info arithmetic division
; @in: arithA: dividend value
; @in: arithB: divisor value
; @out: arithRes1: quotient of division arithA / arithB
; @out: arithRes2: remainder of division arithA % arithB
divARITH:
    RR              :MSTORE(tmpZkPCArith), CALL(storeTmp)
    $ => E          :MLOAD(arithA)
    $ => A          :MLOAD(arithB)
    ; Check denominator(A) is not zero
    0 => B
    $               :EQ, JMPC(zeroDiv)

    ; Check if divisor (E) is smaller than denominator E < A
    A => C ; store temporally A in C
    E => A ; divisor
    C => B ; denominator
    $               :LT, JMPC(divisorSmallerDiv)
    C => A

    ${E%A} => C ; remainder
    ${E/A} => B
    0 => D
    E               :ARITH

    B               :MSTORE(arithRes1)
    C               :MSTORE(arithRes2)

    ; check divisor > remainder
    A => B ; divisor
    C => A ; remainder
    $ => A          :LT
    1               :ASSERT,CALL(loadTmp)
    $ => RR         :MLOAD(tmpZkPCArith)
                    :RETURN

zeroDiv:
    0               :MSTORE(arithRes1)
    0               :MSTORE(arithRes2), CALL(loadTmp)
    $ => RR         :MLOAD(tmpZkPCArith)
                    :RETURN

divisorSmallerDiv:
    0               :MSTORE(arithRes1)
    E               :MSTORE(arithRes2), CALL(loadTmp)
    $ => RR         :MLOAD(tmpZkPCArith)
                    :RETURN

loadTmp:
    $ => A          :MLOAD(tmpVarAArith)
    $ => B          :MLOAD(tmpVarBArith)
    $ => C          :MLOAD(tmpVarCArith)
    $ => D          :MLOAD(tmpVarDArith)
    $ => E          :MLOAD(tmpVarEArith), RETURN

storeTmp:
    A               :MSTORE(tmpVarAArith)
    B               :MSTORE(tmpVarBArith)
    C               :MSTORE(tmpVarCArith)
    D               :MSTORE(tmpVarDArith)
    E               :MSTORE(tmpVarEArith), RETURN
